"""\nHippocampal Neural Signal Simulator\nGenerates realistic electrical impulses from CA1/CA3 hippocampal regions\n"""\n\nimport numpy as np\nfrom typing import Tuple, Optional\n\n\nclass HippocampusSimulator:\n    """\n    Simulates neural activity in the hippocampus for memory encoding/retrieval.\n    Models electrical impulses from CA1 and CA3 regions during episodic memory formation.\n    """\n    \n    def __init__(self, sampling_rate: int = 1000, num_channels: int = 8):\n        """\n        Initialize hippocampus simulator.\n        \n        Args:\n            sampling_rate: Hz, typical neural recording rate (1000-2000 Hz)\n            num_channels: Number of electrode channels (typically 4-16)\n        """\n        self.sampling_rate = sampling_rate\n        self.num_channels = num_channels\n        self.time = None\n        self.signals = None\n        \n    def generate_theta_rhythm(self, duration: float, frequency: float = 8.0) -> np.ndarray:\n        """\n        Generate theta rhythm (4-12 Hz) - critical for memory encoding.\n        \n        Args:\n            duration: Signal duration in seconds\n            frequency: Theta frequency in Hz (default 8 Hz)\n            \n        Returns:\n            Array of theta oscillation values\n        """\n        t = np.linspace(0, duration, int(duration * self.sampling_rate))\n        theta = np.sin(2 * np.pi * frequency * t)\n        return theta\n    \n    def generate_gamma_rhythm(self, duration: float, frequency: float = 40.0) -> np.ndarray:\n        """\n        Generate gamma rhythm (30-100 Hz) - associated with memory retrieval.\n        \n        Args:\n            duration: Signal duration in seconds\n            frequency: Gamma frequency in Hz (default 40 Hz)\n            \n        Returns:\n            Array of gamma oscillation values\n        """\n        t = np.linspace(0, duration, int(duration * self.sampling_rate))\n        gamma = 0.5 * np.sin(2 * np.pi * frequency * t)\n        return gamma\n    \n    def add_noise(self, signal: np.ndarray, noise_level: float = 0.1) -> np.ndarray:\n        """\n        Add realistic neural noise to signal.\n        \n        Args:\n            signal: Clean neural signal\n            noise_level: Standard deviation of Gaussian noise\n            \n        Returns:\n            Noisy signal\n        """\n        noise = noise_level * np.random.randn(*signal.shape)\n        return signal + noise\n    \n    def generate_memory_encoding_pattern(self, duration: float = 2.0, \n                                         impaired: bool = False) -> Tuple[np.ndarray, np.ndarray]:\n        """\n        Generate hippocampal activity during memory encoding.\n        Simulates normal vs. impaired (Alzheimer's) neural patterns.\n        \n        Args:\n            duration: Recording duration in seconds\n            impaired: If True, simulates Alzheimer's-damaged patterns\n            \n        Returns:\n            time: Time array\n            signals: Multi-channel neural signals (channels x timepoints)\n        """\n        t = np.linspace(0, duration, int(duration * self.sampling_rate))\n        signals = np.zeros((self.num_channels, len(t)))\n        \n        for ch in range(self.num_channels):\n            # Each channel has theta + gamma components\n            theta = self.generate_theta_rhythm(duration)\n            gamma = self.generate_gamma_rhythm(duration)\n            \n            # Combine oscillations\n            base_signal = theta + gamma\n            \n            if impaired:\n                # Alzheimer's reduces theta/gamma synchronization\n                degradation = 0.3 + 0.2 * np.random.rand()  # 30-50% signal loss\n                base_signal *= degradation\n                # Increased noise in damaged tissue\n                signals[ch, :] = self.add_noise(base_signal, noise_level=0.3)\n            else:\n                signals[ch, :] = self.add_noise(base_signal, noise_level=0.1)\n        \n        self.time = t\n        self.signals = signals\n        return t, signals\n    \n    def get_spike_train(self, threshold: float = 0.5) -> np.ndarray:\n        """\n        Extract spike times from continuous signals (action potentials).\n        \n        Args:\n            threshold: Voltage threshold for spike detection\n            \n        Returns:\n            Binary spike matrix (channels x timepoints)\n        """\n        if self.signals is None:\n            raise ValueError("No signals generated. Call generate_memory_encoding_pattern first.")\n        \n        spikes = (self.signals > threshold).astype(int)\n        return spikes\n\n\nif __name__ == "__main__":\n    # Demo: Generate normal vs impaired hippocampal signals\n    sim = HippocampusSimulator(sampling_rate=1000, num_channels=4)\n    \n    print("Generating NORMAL hippocampal memory encoding pattern...")\n    t_normal, signals_normal = sim.generate_memory_encoding_pattern(duration=1.0, impaired=False)\n    print(f"Signal shape: {signals_normal.shape}")\n    print(f"Time range: {t_normal[0]:.3f}s to {t_normal[-1]:.3f}s")\n    print(f"Sample values (Channel 0): {signals_normal[0, :5]}")\n    \n    print("\nGenerating IMPAIRED (Alzheimer's) hippocampal pattern...")\n    t_impaired, signals_impaired = sim.generate_memory_encoding_pattern(duration=1.0, impaired=True)\n    print(f"Signal amplitude comparison:")\n    print(f"  Normal RMS: {np.sqrt(np.mean(signals_normal**2)):.3f}")\n    print(f"  Impaired RMS: {np.sqrt(np.mean(signals_impaired**2)):.3f}")\n