"""\nElectrode Array Simulator\nModels physical electrode placement and signal acquisition from hippocampus\n"""\n\nimport numpy as np\nfrom typing import Tuple, List\n\n\nclass ElectrodeArray:\n    """\n    Simulates multi-electrode array implanted in hippocampus.\n    Models spatial positioning and signal capture characteristics.\n    """\n    \n    def __init__(self, num_electrodes: int = 64, spacing_mm: float = 0.4):\n        """\n        Initialize electrode array.\n        \n        Args:\n            num_electrodes: Number of recording sites (typical: 16-256)\n            spacing_mm: Distance between electrodes in millimeters\n        """\n        self.num_electrodes = num_electrodes\n        self.spacing_mm = spacing_mm\n        self.positions = self._generate_positions()\n        \n    def _generate_positions(self) -> np.ndarray:\n        """\n        Generate 3D positions of electrodes in hippocampal tissue.\n        \n        Returns:\n            Array of shape (num_electrodes, 3) with x,y,z coordinates in mm\n        """\n        # Linear array along CA1-CA3 axis\n        positions = np.zeros((self.num_electrodes, 3))\n        positions[:, 0] = np.arange(self.num_electrodes) * self.spacing_mm\n        # Add slight vertical offset for depth\n        positions[:, 2] = np.random.uniform(2.0, 3.5, self.num_electrodes)\n        return positions\n    \n    def apply_spatial_filtering(self, neural_activity: np.ndarray, \n                               source_position: np.ndarray) -> np.ndarray:\n        """\n        Apply distance-dependent attenuation to neural signals.\n        \n        Args:\n            neural_activity: Raw neural signal\n            source_position: 3D position of neural source (mm)\n            \n        Returns:\n            Signal as recorded by each electrode\n        """\n        recorded_signals = np.zeros((self.num_electrodes, len(neural_activity)))\n        \n        for i, electrode_pos in enumerate(self.positions):\n            # Calculate distance from source to electrode\n            distance = np.linalg.norm(electrode_pos - source_position)\n            # 1/r^2 attenuation\n            attenuation = 1.0 / (1.0 + distance**2)\n            recorded_signals[i, :] = neural_activity * attenuation\n            \n        return recorded_signals\n    \n    def get_impedance(self, electrode_idx: int) -> float:\n        """\n        Get electrode impedance (important for signal quality).\n        \n        Args:\n            electrode_idx: Index of electrode\n            \n        Returns:\n            Impedance in k立 (typical range: 50-500 k立)\n        """\n        # Simulate realistic impedance variation\n        base_impedance = 200.0  # k立\n        variation = np.random.uniform(0.8, 1.2)\n        return base_impedance * variation\n\n\nif __name__ == "__main__":\n    # Demo\n    array = ElectrodeArray(num_electrodes=16, spacing_mm=0.4)\n    print(f"Electrode array: {array.num_electrodes} channels")\n    print(f"Positions (first 3):\n{array.positions[:3]}")
    print(f"\nSample impedances:")
    for i in range(3):
        print(f"  Electrode {i}: {array.get_impedance(i):.1f} k立")\n