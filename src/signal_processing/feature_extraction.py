"""\nFeature Extraction Module\nExtracts spike features and spectral power from neural signals\n"""\n\nimport numpy as np\nfrom scipy import signal as sp_signal\nfrom typing import Dict, Tuple\n\n\nclass FeatureExtractor:\n    """\n    Extracts features from filtered neural signals for ML model input.\n    """\n    \n    def __init__(self, sampling_rate: int = 1000):\n        self.fs = sampling_rate\n    \n    def compute_power_spectral_density(self, data: np.ndarray, \n                                      freq_bands: Dict[str, Tuple[float, float]]) -> Dict[str, float]:\n        """\n        Compute power in different frequency bands.\n        \n        Args:\n            data: Neural signal\n            freq_bands: Dict of band names to (low, high) frequency tuples\n            \n        Returns:\n            Dict of band powers\n        """\n        freqs, psd = sp_signal.welch(data, fs=self.fs, nperseg=256)\n        band_powers = {}\n        \n        for band_name, (low, high) in freq_bands.items():\n            idx = np.logical_and(freqs >= low, freqs <= high)\n            band_powers[band_name] = np.trapz(psd[idx], freqs[idx])\n        \n        return band_powers\n    \n    def extract_spike_features(self, spikes: np.ndarray) -> Dict[str, float]:\n        """\n        Extract features from spike train.\n        \n        Args:\n            spikes: Binary spike matrix\n            \n        Returns:\n            Dict of spike features\n        """\n        firing_rate = np.sum(spikes) / (len(spikes) / self.fs)\n        isi = np.diff(np.where(spikes)[0]) / self.fs  # Inter-spike intervals\n        cv_isi = np.std(isi) / np.mean(isi) if len(isi) > 0 else 0\n        \n        return {\n            'firing_rate': firing_rate,\n            'cv_isi': cv_isi,\n            'burst_index': np.sum(isi < 0.01) / len(isi) if len(isi) > 0 else 0\n        }\n    \n    def compute_theta_gamma_coupling(self, theta: np.ndarray, gamma: np.ndarray) -> float:\n        """\n        Compute phase-amplitude coupling between theta and gamma.\n        Critical for memory encoding assessment.\n        """\n        from scipy.signal import hilbert\n        \n        theta_phase = np.angle(hilbert(theta))\n        gamma_amplitude = np.abs(hilbert(gamma))\n        \n        # Modulation index\n        phase_bins = np.linspace(-np.pi, np.pi, 18)\n        amp_mean = []\n        for i in range(len(phase_bins) - 1):\n            idx = np.logical_and(theta_phase >= phase_bins[i], theta_phase < phase_bins[i+1])\n            amp_mean.append(np.mean(gamma_amplitude[idx]))\n        \n        amp_mean = np.array(amp_mean)\n        mi = (np.max(amp_mean) - np.min(amp_mean)) / (np.max(amp_mean) + np.min(amp_mean))\n        return mi\n\n\nif __name__ == "__main__":\n    from src.signal_simulator.hippocampus_sim import HippocampusSimulator\n    from src.signal_processing.filter import NeuralFilter\n    \n    sim = HippocampusSimulator()\n    t, signals = sim.generate_memory_encoding_pattern(duration=2.0)\n    \n    filt = NeuralFilter()\n    theta = filt.extract_theta(signals[0, :])\n    gamma = filt.extract_gamma(signals[0, :])\n    \n    extractor = FeatureExtractor()\n    freq_bands = {'theta': (4, 12), 'gamma': (30, 100)}\n    powers = extractor.compute_power_spectral_density(signals[0, :], freq_bands)\n    coupling = extractor.compute_theta_gamma_coupling(theta, gamma)\n    \n    print(f"Theta power: {powers['theta']:.3f}")\n    print(f"Gamma power: {powers['gamma']:.3f}")\n    print(f"Theta-gamma coupling: {coupling:.3f}")\n