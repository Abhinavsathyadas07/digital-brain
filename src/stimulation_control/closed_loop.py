"""\nClosed-Loop Stimulation Controller\nGenerates corrective electrical stimulation based on ML predictions\n"""\n\nimport numpy as np\nfrom typing import Tuple, Dict\nimport time\n\n\nclass ClosedLoopController:\n    """\n    Real-time closed-loop controller for hippocampal stimulation.\n    Monitors memory encoding and applies corrective stimulation when needed.\n    """\n    \n    def __init__(self, sampling_rate: int = 1000, max_current_ua: float = 200.0):\n        """\n        Initialize stimulation controller.\n        \n        Args:\n            sampling_rate: Hz, must match signal acquisition\n            max_current_ua: Maximum stimulation current in microamperes (safety limit)\n        """\n        self.fs = sampling_rate\n        self.max_current = max_current_ua\n        self.stimulation_history = []\n        self.safety_timeout = 5.0  # seconds between stimulation bursts\n        self.last_stim_time = 0\n    \n    def should_stimulate(self, memory_prediction: float, threshold: float = 0.5) -> bool:\n        """\n        Decide if stimulation is needed based on ML prediction.\n        \n        Args:\n            memory_prediction: Probability of successful memory encoding (0-1)\n            threshold: Stimulate if prediction below this value\n            \n        Returns:\n            True if stimulation should be applied\n        """\n        # Check if memory encoding is failing\n        if memory_prediction >= threshold:\n            return False\n        \n        # Check safety timeout\n        current_time = time.time()\n        if current_time - self.last_stim_time < self.safety_timeout:\n            return False\n        \n        return True\n    \n    def generate_stimulation_pattern(self, duration_ms: float = 100, \n                                    frequency_hz: float = 8.0, \n                                    amplitude_ua: float = 150.0) -> np.ndarray:\n        """\n        Generate theta-frequency stimulation pattern.\n        \n        Args:\n            duration_ms: Stimulation duration in milliseconds\n            frequency_hz: Stimulation frequency (typically theta: 4-12 Hz)\n            amplitude_ua: Current amplitude in microamperes\n            \n        Returns:\n            Stimulation waveform (time series)\n        """\n        # Safety check\n        if amplitude_ua > self.max_current:\n            print(f"WARNING: Amplitude {amplitude_ua} exceeds safety limit {self.max_current}")\n            amplitude_ua = self.max_current\n        \n        # Generate biphasic pulse train\n        duration_s = duration_ms / 1000.0\n        t = np.linspace(0, duration_s, int(duration_s * self.fs))\n        \n        # Theta-frequency pulse train\n        pulse_train = amplitude_ua * np.sin(2 * np.pi * frequency_hz * t)\n        \n        # Make biphasic (charge-balanced)\n        pulse_train = np.clip(pulse_train, 0, None)  # Positive phase\n        negative_phase = -0.5 * pulse_train  # Smaller negative phase for charge balance\n        \n        stimulation = np.concatenate([pulse_train, negative_phase])\n        \n        return stimulation\n    \n    def apply_stimulation(self, target_electrodes: list, \n                         stimulation_pattern: np.ndarray) -> Dict[str, any]:\n        """\n        Apply stimulation to specified electrodes.\n        \n        Args:\n            target_electrodes: List of electrode indices to stimulate\n            stimulation_pattern: Waveform to apply\n            \n        Returns:\n            Dict with stimulation metadata\n        """\n        self.last_stim_time = time.time()\n        \n        stim_info = {\n            'timestamp': self.last_stim_time,\n            'electrodes': target_electrodes,\n            'duration_ms': len(stimulation_pattern) / self.fs * 1000,\n            'amplitude_ua': np.max(np.abs(stimulation_pattern)),\n            'total_charge_nc': np.sum(np.abs(stimulation_pattern)) / self.fs * 1e3  # nanocoulombs\n        }\n        \n        self.stimulation_history.append(stim_info)\n        \n        print(f"✓ Stimulation applied to electrodes {target_electrodes}")\n        print(f"  Duration: {stim_info['duration_ms']:.1f} ms")\n        print(f"  Amplitude: {stim_info['amplitude_ua']:.1f} μA")\n        print(f"  Total charge: {stim_info['total_charge_nc']:.2f} nC")\n        \n        return stim_info\n    \n    def run_closed_loop(self, decoder, neural_signals: np.ndarray, \n                       target_electrodes: list = [0, 1]) -> Dict[str, any]:\n        """\n        Run one cycle of closed-loop control.\n        \n        Args:\n            decoder: Trained MemoryDecoder instance\n            neural_signals: Real-time neural signals\n            target_electrodes: Which electrodes to use for stimulation\n            \n        Returns:\n            Dict with control loop results\n        """\n        # Predict memory encoding success\n        predictions = decoder.predict(neural_signals)\n        memory_prob = predictions[0, 1]  # Probability of successful encoding\n        \n        result = {\n            'memory_probability': memory_prob,\n            'stimulation_applied': False,\n            'stimulation_info': None\n        }\n        \n        # Decide if stimulation needed\n        if self.should_stimulate(memory_prob, threshold=0.6):\n            # Generate and apply stimulation\n            stim_pattern = self.generate_stimulation_pattern(\n                duration_ms=100,\n                frequency_hz=8.0,  # Theta frequency\n                amplitude_ua=150.0\n            )\n            \n            stim_info = self.apply_stimulation(target_electrodes, stim_pattern)\n            result['stimulation_applied'] = True\n            result['stimulation_info'] = stim_info\n        else:\n            print(f"Memory encoding sufficient ({memory_prob:.2%}), no stimulation needed.")\n        \n        return result\n\n\nif __name__ == "__main__":\n    # Demo closed-loop control\n    from src.signal_simulator.hippocampus_sim import HippocampusSimulator\n    from src.ml_model.memory_decoder import MemoryDecoder\n    \n    print("\n=== CLOSED-LOOP STIMULATION DEMO ===")\n    \n    # Create impaired signal (should trigger stimulation)\n    sim = HippocampusSimulator(num_channels=8)\n    _, impaired_signal = sim.generate_memory_encoding_pattern(duration=1.0, impaired=True)\n    \n    print("\nGenerating impaired hippocampal signal...")\n    print(f"Signal RMS: {np.sqrt(np.mean(impaired_signal**2)):.3f}")\n    \n    # Create mock trained decoder\n    decoder = MemoryDecoder(input_dim=8)\n    # Note: In real use, decoder would be pre-trained\n    \n    # Initialize controller\n    controller = ClosedLoopController(sampling_rate=1000, max_current_ua=200.0)\n    \n    print("\nGenerating stimulation pattern...")
    stim = controller.generate_stimulation_pattern(duration_ms=100, frequency_hz=8.0, amplitude_ua=150.0)\n    print(f"Stimulation waveform shape: {stim.shape}")\n    print(f"Peak current: {np.max(stim):.1f} μA")\n    print(f"Charge balanced: {np.abs(np.sum(stim)) < 1e-6}")\n